<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Publications – Rui Wang</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-4d9afe2b8d18ee9fa5d0d57b5ed4214d.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-f93c2b1f3f0577f377aefa4848a86a36.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-0d4a9d19931feb4fee1ddab4b2489000.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-f93c2b1f3f0577f377aefa4848a86a36.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles/styles.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Rui Wang</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../pages/publications.html" aria-current="page"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../pages/teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../files/CV_new.pdf"> 
<span class="menu-text">CV/Resume</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preprints-submitted" id="toc-preprints-submitted" class="nav-link active" data-scroll-target="#preprints-submitted">Preprints / Submitted</a></li>
  <li><a href="#journal-articles-in-press" id="toc-journal-articles-in-press" class="nav-link" data-scroll-target="#journal-articles-in-press">Journal Articles / In Press</a>
  <ul class="collapse">
  <li><a href="#section" id="toc-section" class="nav-link" data-scroll-target="#section">2026</a></li>
  <li><a href="#section-1" id="toc-section-1" class="nav-link" data-scroll-target="#section-1">2025</a></li>
  <li><a href="#section-2" id="toc-section-2" class="nav-link" data-scroll-target="#section-2">2024</a></li>
  <li><a href="#section-3" id="toc-section-3" class="nav-link" data-scroll-target="#section-3">2022</a></li>
  <li><a href="#section-4" id="toc-section-4" class="nav-link" data-scroll-target="#section-4">2021</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Publications</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="preprints-submitted" class="level2">
<h2 class="anchored" data-anchor-id="preprints-submitted">Preprints / Submitted</h2>
<ul>
<li><p>Deng, Y., <strong>Wang, R.</strong>, Zhan, X. (2026+). Randomized interventional effects for semicompeteting risks, with application to allogeneic stem cell transplantation study. <a href="https://arxiv.org/abs/2412.06114">arXiv</a></p></li>
<li><p><strong>Wang, R.</strong>, Zhao, Y., Dukes, O., Zhang, B. (2026+). Nested Instrumental Variables Analysis: Switcher Average Treatment Effect, Identification, Efficient Estimation and Generalizability. <a href="https://arxiv.org/abs/2405.07102">arXiv</a></p></li>
<li><p><strong>Wang, R.</strong>, Chan, KCG., Ye, T. (2026+). GMM with Many Weak Moment Conditions and Nuisance Parameters: General Theory and Applications to Causal Inference. <a href="https://arxiv.org/abs/2505.07295">arXiv</a></p></li>
<li><p>Wang, Z., Sourial, N., <strong>Wang, R.</strong>, Bergman, H., Liu, X., Vedel, I. (2026+). Neo-Familist Values and Health-Seeking Behaviours Among Older Adults in Rural China: Evidence from China Longitudinal Aging Social Survey (CLASS).</p></li>
</ul>
</section>
<section id="journal-articles-in-press" class="level2">
<h2 class="anchored" data-anchor-id="journal-articles-in-press">Journal Articles / In Press</h2>
<section id="section" class="level3">
<h3 class="anchored" data-anchor-id="section">2026</h3>
<ol type="1">
<li><strong>Wang, R.</strong>, Heagerty, P., Chan, KCG., Suri, P. (2026). Estimating controlled direct treatment effects on pain intensity using structural mean models: a general approach for pain randomized controlled trials. Accepted at <em>Pain Reports</em>.</li>
</ol>
</section>
<section id="section-1" class="level3">
<h3 class="anchored" data-anchor-id="section-1">2025</h3>
<ol type="1">
<li><p>Joshi, M. A., Manubolu, V. S., Kinninger, A., <strong>Wang, R.</strong>, McClelland, R. L., Roy, R. K., Budoff, M. J. (2025). Sex Differences in Aortic Arch Calcification with Zero Coronary Artery Calcium. <em>Heart, Lung and Circulation</em>. <a href="https://doi.org/10.1016/j.hlc.2025.05.087">DOI</a></p>
<details>
<summary>
<p><strong>Abstract</strong></p>
</summary>
<p><strong>Background</strong> Studies have linked aortic calcification to an increased risk of all-cause mortality and cardiovascular mortality. There is minimal evidence evaluating the sex differences in the prevalence of aortic arch calcification (AAC) in relation to zero coronary artery calcium (CAC). <strong>Method</strong> This study included participants from the Multi-Ethnic Study of Atherosclerosis (MESA) exam 5, of which 2,564 underwent non-contrast chest computed tomography scans. We utilised the CAC and AAC scores measured by the Agatston method to evaluate sex differences in AAC among participants overall, and among those with zero CAC. Regression analysis was performed, adjusting for covariates, to evaluate the sex difference. <strong>Results</strong> The average age of the 2,564 participants was 69.2±9.2 years, 46% were women, 38% were White, 13% were Chinese, 27% were Black, and 22% were Hispanic/Latino. A total of 813 (32%) had a CAC of zero. The prevalence of AAC was higher in women than men, both in the zero CAC population (87% vs 80%) and overall (92% vs 90%). The median AAC was additionally higher in women in the overall population (217 vs 212) and in the CAC zero population (60 vs 20). After controlling for covariates, the estimated average AAC was 0.51 times lower in men than women (95% confidence interval 0.36–0.72; p&lt;0.001) in the CAC zero population. <strong>Conclusions</strong> This study demonstrated that the prevalence of aortic arch calcium is higher in women compared to men. In a subset of the population with zero CAC, the average amount of AAC is significantly higher in women. In the future, event analysis should be done to determine whether these sex differences in AAC may partially explain the sex differences in the prediction of atherosclerotic cardiovascular disease events.</p>
</details></li>
<li><p>Deng, Y., <strong>Wang, R.</strong> (2025). Adjusted Nelson–Aalen Estimators by Inverse Treatment Probability Weighting With an Estimated Propensity Score. <em>Statistics in Medicine</em>, 44: e70085. <a href="https://doi.org/10.1002/sim.70085">DOI</a></p>
<details>
<summary>
<p><strong>Abstract</strong></p>
</summary>
<p>Inverse probability of treatment weighting (IPW) has been well applied in causal inference to estimate population-level estimands from observational studies. For time-to-event outcomes, the failure time distribution can be estimated by estimating the cumulative hazard in the presence of random right censoring. IPW can be performed by weighting the event counting process and at-risk process by the inverse treatment probability, resulting in an adjusted Nelson–Aalen estimator for the population-level counterfactual cumulative incidence function. We consider the adjusted Nelson–Aalen estimator with an estimated propensity score in the competing risks setting. When the estimated propensity score is regular and asymptotically linear, we derive the influence functions for the counterfactual cumulative hazard and cumulative incidence. Then we establish the asymptotic properties for the estimators. We show that the uncertainty in the estimated propensity score contributes to an additional variation in the estimators. However, through simulation and real-data application, we find that such an additional variation is usually small.</p>
</details></li>
</ol>
</section>
<section id="section-2" class="level3">
<h3 class="anchored" data-anchor-id="section-2">2024</h3>
<ol type="1">
<li><p>Barforoshi, S., Manubolu, V. S., <strong>Wang, R.</strong>, McClelland, R. L., Budoff, M. J. (2024). Incremental value of ABI and CAC beyond traditional risk markers in long-term prediction of cardiovascular disease incidence in participants with diabetes and impaired fasting glucose: Multi-Ethnic Study of Atherosclerosis. <em>Atherosclerosis</em>, 117186. <a href="https://doi.org/10.1016/j.atherosclerosis.2023.117186">DOI</a></p>
<details>
<summary>
<p><strong>Abstract</strong></p>
</summary>
<p><strong>Background and aims</strong> Subclinical atherosclerosis (SA) diagnosis is key to primary prevention of atherosclerotic cardiovascular disease (ASCVD). SA is common among diabetics. Ankle brachial index (ABI) and coronary artery calcium (CAC) are markers of SA. This study examined whether adding ABI and CAC to diabetic individuals improved ASCVD risk prediction beyond established risk factors. <strong>Methods</strong> MESA is an observational cohort of 6814 participants without clinical cardiovascular disease. All participants with diabetes and impaired fasting glucose were included in the analysis. The association between CAC, ABI, and incident ASCVD, and all-cause mortality was examined using Cox proportional hazard regression. The risk prediction models including ABI and/or CAC in addition to standard risk factors alone were compared. <strong>Results</strong> Of the 1719 participants, 55% were male and average age was 64 (±9.6) years old. Participants with diabetes or impaired fasting glucose with higher CAC and lower ABI had higher ASCVD and all-cause mortality. ABI and CAC enhanced ASCVD discrimination over standard risk factors, with C-index (95% CI) of 0.689 (0.66, 0.718) for risk factors alone, 0.696 (0.668, 0.724) for ABI, 0.719 (0.691, 0.747) for CAC, and 0.721 (0.693, 0.749) for CAC + ABI. Similarly, for all-cause mortality, both CAC and ABI improved risk discrimination in addition to standard risk factors alone. <strong>Conclusions</strong> In a large population-based study of individuals with diabetes or impaired fasting glucose, the addition of ABI and CAC to conventional risk factors improved 10-year ASCVD risk prediction. ABI and CAC are non-invasive and cost-effective tests; therefore, these markers should be included into ASCVD risk stratification for primary prevention in the diabetic and impaired fasting glucose population.</p>
</details></li>
<li><p>Ichikawa, K., <strong>Wang, R.</strong>, McClelland, R. L., Manubolu, V. S., Susarla, S., Lee, D., Pourafkari, L., Fazlalizadeh, H., Aldana-Bitar, J., Robin, R., Kinninger, A., Roy, S. K., Post, W. S., Budoff, M. J. (2024). The prognostic value of thoracic aortic calcification comparison with coronary artery calcification. <em>Heart</em>. <a href="https://doi.org/10.1136/heartjnl-2023-323838">DOI</a></p>
<details>
<summary>
<p><strong>Abstract</strong></p>
</summary>
<p>This study compared the prognostic value of quantified thoracic artery calcium (TAC) including aortic arch on chest CT and coronary artery calcium (CAC) score on ECG-gated cardiac CT. <strong>Methods</strong> A total of 2412 participants who underwent both chest CT and ECG-gated cardiac CT at the same period were included in the Multi-Ethnic Study of Atherosclerosis Exam 5. All participants were monitored for incident atherosclerotic cardiovascular disease (ASCVD) events. TAC is defined as calcification in the ascending aorta, aortic arch and descending aorta on chest CT. The quantification of TAC was measured using the Agatston method. Time-dependent receiver-operating characteristic (ROC) curves were used to compare the prognostic value of TAC and CAC scores. <strong>Results</strong> Participants were 69±9 years of age and 47% were male. The Spearman correlation between TAC and CAC scores was 0.46 (p&lt;0.001). During the median follow-up period of 8.8 years, 234 participants (9.7%) experienced ASCVD events. In multivariable Cox regression analysis, TAC score was independently associated with increased risk of ASCVD events (HR 1.31, 95% CI 1.09 to 1.58) as well as CAC score (HR 1.82, 95% CI 1.53 to 2.17). However, the area under the time-dependent ROC curve for CAC score was greater than that for TAC score in all participants (0.698 and 0.641, p=0.031). This was particularly pronounced in participants with borderline/intermediate and high 10-year ASCVD risk scores. <strong>Conclusion</strong> Our study demonstrated a significant association between TAC and CAC scores but a superior prognostic value of CAC score for ASCVD events. These findings suggest TAC on chest CT provides supplementary data to estimate ASCVD risk but does not replace CAC on ECG-gated cardiac CT.</p>
</details></li>
</ol>
</section>
<section id="section-3" class="level3">
<h3 class="anchored" data-anchor-id="section-3">2022</h3>
<ol type="1">
<li><p><strong>Wang, R.</strong>, Wang, J., Hu, T., Zhou, X.-H. (2022). Population-Level Effectiveness of COVID-19 Vaccination Program in the United States: Causal Analysis Based on Structural Nested Mean Model. <em>Vaccines</em>. <a href="https://doi.org/10.3390/vaccines10050726">DOI</a></p>
<details>
<summary>
<p><strong>Abstract</strong></p>
</summary>
<p>Though COVID-19 vaccines have shown high efficacy, real-world effectiveness at the population level remains unclear. Based on the longitudinal data on vaccination coverage and daily infection cases from fifty states in the United States from March to May 2021, causal analyses were conducted using structural nested mean models to estimate the population-level effectiveness of the COVID-19 vaccination program against infection with the original strain. We found that in the US, every 1% increase of vaccination coverage rate reduced the weekly growth rate of COVID-19 confirmed cases by 1.02% (95% CI: 0.26%, 1.69%), and the estimated population-level effectiveness of the COVID-19 program was 63.9% (95% CI: 18.0%, 87.5%). In comparison to a no-vaccination scenario, the COVID-19 vaccination campaign averted 8.05 million infections through the study period. Scenario analyses show that a vaccination program with doubled vaccination speed or with more rapid vaccination speed at the early stages of the campaign would avert more infections and increase vaccine effectiveness. The COVID-19 vaccination program demonstrated a high population-level effectiveness and significantly reduced the disease burden in the US. Accelerating vaccine rollout, especially at an early stage of the campaign, is crucial for reducing COVID-19 infections.</p>
</details></li>
</ol>
</section>
<section id="section-4" class="level3">
<h3 class="anchored" data-anchor-id="section-4">2021</h3>
<ol type="1">
<li><p>Deng, Y., Chen, F., Li, Y., Qian, K., <strong>Wang, R.</strong>, Zhou, X.-H. (2021). A powerful test for the maximum treatment effect in thorough QT/QTc studies. <em>Statistics in Medicine</em>, 40(8), 1947–1959. <a href="https://doi.org/10.1002/sim.8881">DOI</a></p>
<details>
<summary>
<p><strong>Abstract</strong></p>
</summary>
<p>Parallel-group thorough QT/QTc studies focus on the change of QT/QTc values at several time-matched points from a pretreatment day (baseline) to a posttreatment day for different groups of treatment. The International Council for Harmonisation E14 stresses that QTc prolongation beyond a threshold represents high cardiac risk and calls for a test on the largest time-matched treatment effect (QTc prolongation). QT/QTc analysis usually assumes a jointly multivariate normal (MVN) distribution of pretreatment and posttreatment QT/QTc values, with a blocked compound symmetry covariance matrix. Existing methods use an analysis of covariance (ANCOVA) model including day-averaged baseline as a covariate to deal with the MVN model. However, the ANCOVA model tends to underestimate the variation of the estimator for treatment effects, resulting in the inflation of empirical type I error rate when testing whether the largest QTc prolongation is beyond a threshold. In this article, we propose two new methods to estimate the time-matched treatment effects under the MVN model, including maximum likelihood estimation and ordinary-least-square-based two-stage estimation. These two methods take advantage of the covariance structure and are asymptotically efficient. Based on these estimators, powerful tests for QT/QTc prolongation are constructed. Simulation shows that the proposed estimators have smaller mean square error, and the tests can control the type I error rate with high power. The proposed methods are applied on testing the carryover effect of diltiazem to inhibit dofetilide in a randomized phase 1 trial.</p>
</details></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>